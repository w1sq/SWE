# Модуль "Учет финансов"

Консольное приложение для управления личными финансами с поддержкой учета доходов и расходов, категоризации, анализа и экспорта/импорта данных.

## Общее описание решения

Модуль "Учет финансов" представляет собой консольное приложение для управления личными финансами, разработанное с применением принципов объектно-ориентированного программирования, SOLID, GRASP и паттернов проектирования GoF.

### Реализованный функционал:

1. **Основные требования**:
   - Создание, редактирование и удаление счетов, категорий и операций (доходов/расходов)
   - Вывод списков всех объектов

2. **Аналитика**:
   - Подсчет разницы доходов и расходов за выбранный период
   - Группировка доходов и расходов по категориям
   - Анализ несоответствий в балансах счетов

3. **Импорт и экспорт данных**:
   - Экспорт операций в форматы CSV, JSON, YAML
   - Импорт операций из форматов CSV, JSON, YAML

4. **Управление данными**:
   - Пересчет баланса счетов при обнаружении несоответствий
   - Валидация создаваемых и обновляемых объектов

5. **Статистика**:
   - Измерение времени работы отдельных пользовательских сценариев
   - Формирование отчета о производительности

## Применение принципов SOLID и GRASP

### SOLID

1. **Single Responsibility Principle (SRP)**:
   - Каждый класс имеет ограниченную зону ответственности.
   - Примеры: 
     - `BankAccount` отвечает только за операции со счетом
     - `OperationValidator` занимается только валидацией операций
     - `CSVExporter` только экспортирует данные в CSV

2. **Open/Closed Principle (OCP)**:
   - Классы открыты для расширения, но закрыты для модификации.
   - Примеры:
     - Иерархия `Repository` позволяет добавлять новые типы репозиториев без изменения существующего кода
     - Иерархия `DataExporter` и `DataImporter` позволяет добавлять новые форматы

3. **Liskov Substitution Principle (LSP)**:
   - Подклассы можно использовать вместо их базовых классов.
   - Примеры:
     - Все реализации `Repository` следуют одному интерфейсу
     - Все `EntityValidator` следуют одному интерфейсу

4. **Interface Segregation Principle (ISP)**:
   - Интерфейсы разделены по функциональности.
   - Примеры:
     - Абстрактные классы `Repository`, `EntityValidator`, `Command` определяют минимально необходимые методы

5. **Dependency Inversion Principle (DIP)**:
   - Зависимости инвертированы через абстракции.
   - Примеры:
     - Класс `FinanceModuleContainer` управляет зависимостями
     - Высокоуровневые компоненты (фасады) зависят от абстракций (репозитории), а не от конкретных реализаций

### GRASP

1. **High Cohesion**:
   - Элементы модуля тесно связаны между собой для решения конкретной задачи.
   - Примеры:
     - Классы в `models.py` представляют связные сущности доменной модели
     - `AnalyticsService` группирует методы аналитики

2. **Low Coupling**:
   - Модули минимально зависят друг от друга.
   - Примеры:
     - Использование интерфейсов и абстрактных классов для разделения компонентов
     - Фасады скрывают сложность работы с репозиториями

3. **Controller**:
   - Координация действий других объектов.
   - Примеры:
     - `ConsoleApp` координирует взаимодействие пользователя с системой
     - Фасады (`BankAccountFacade`, `CategoryFacade`, `OperationFacade`) управляют потоком данных и бизнес-логикой

4. **Creator**:
   - Объекты создаются в правильном месте.
   - Примеры:
     - `EntityFactory` отвечает за создание сущностей доменной модели

5. **Information Expert**:
   - Ответственность за действия назначается объектам, обладающим необходимой информацией.
   - Примеры:
     - `AnalyticsService` выполняет аналитические расчеты, так как имеет доступ ко всем необходимым данным

## Применение паттернов GoF

### Порождающие паттерны

1. **Фабрика (Factory Method)**
   - Класс: `EntityFactory` в `factories.py`
   - Важность: Обеспечивает централизованное создание объектов доменной модели, скрывая детали создания
   - Применение: Создание новых счетов, категорий и операций с нужной инициализацией

2. **Контейнер зависимостей (Dependency Injection Container)**
   - Класс: `FinanceModuleContainer` в `container.py`
   - Важность: Централизует создание и управление зависимостями, облегчает тестирование
   - Применение: Управляет созданием и предоставлением доступа ко всем сервисам приложения

### Структурные паттерны

1. **Фасад (Facade)**
   - Классы: `BankAccountFacade`, `CategoryFacade`, `OperationFacade` в `facades.py`
   - Важность: Предоставляет простой интерфейс для сложной подсистемы
   - Применение: Упрощает работу с доменной моделью, скрывая детали работы с репозиториями и валидаторами

2. **Прокси (Proxy)**
   - Класс: `OperationRepositoryProxy` в `proxy.py`
   - Важность: Контролирует доступ к объекту, добавляя функциональность (кэширование)
   - Применение: Кэширование результатов для улучшения производительности

3. **Декоратор (Decorator)**
   - Классы: `PerformanceDecorator` в `performance.py`, функция `measure_execution_time`
   - Важность: Динамически добавляет новое поведение объектам
   - Применение: Измерение времени выполнения пользовательских сценариев

### Поведенческие паттерны

1. **Команда (Command)**
   - Классы: `Command` (абстрактный), `GetOperationsCommand` в `commands.py`
   - Важность: Инкапсулирует запрос как объект, параметризуя клиентов с запросами
   - Применение: Выполнение и измерение производительности различных пользовательских сценариев

2. **Шаблонный метод (Template Method)**
   - Классы: `DataExporter` и `DataImporter` (абстрактные) и их наследники в `exporters.py` и `importers.py`
   - Важность: Определяет скелет алгоритма, позволяя подклассам переопределять его шаги
   - Применение: Стандартизация процесса экспорта/импорта данных для разных форматов (CSV, JSON, YAML)

## Структура проекта

```
finance_module/
├── models.py             # Доменные модели (BankAccount, Category, Operation)
├── repositories.py       # Репозитории для работы с данными
├── validators.py         # Валидаторы для проверки сущностей
├── factories.py          # Фабрики для создания объектов
├── facades.py            # Фасады для упрощения работы с доменными объектами
├── analytics.py          # Аналитические сервисы
├── exporters.py          # Экспорт данных (CSV, JSON, YAML)
├── importers.py          # Импорт данных (CSV, JSON, YAML)
├── commands.py           # Реализация паттерна Команда
├── proxy.py              # Реализация паттерна Прокси для кэширования
├── performance.py        # Функции и классы для измерения производительности
├── container.py          # Контейнер для управления зависимостями
├── console_app.py        # Консольный интерфейс пользователя
├── main.py               # Точка входа в приложение
├── requirements.txt      # Зависимости проекта
└── tests/                # Тесты
```

## Инструкция по запуску

1. Создайте виртуальное окружение:
```bash
python -m venv venv
```

2. Активируйте виртуальное окружение:
   - На Windows:
   ```bash
   venv\Scripts\activate
   ```
   - На Linux/Mac:
   ```bash
   source venv/bin/activate
   ```

3. Установите зависимости:
```bash
pip install -r requirements.txt
```

4. Запустите приложение:
```bash
python main.py
```

5. Запустите тесты:
```bash
PYTHONPATH=. pytest --cov=. --cov-report=term
```

## Заключение

Данная реализация модуля "Учет финансов" демонстрирует применение принципов объектно-ориентированного проектирования, SOLID, GRASP и паттернов GoF для создания гибкого, расширяемого и поддерживаемого приложения. Архитектура проекта позволяет легко добавлять новую функциональность без изменения существующего кода.

Использование паттернов проектирования обеспечивает решение типичных проблем разработки программного обеспечения и улучшает структуру кода, делая его более модульным и тестируемым.
